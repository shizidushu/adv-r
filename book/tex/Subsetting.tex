\chapter{Subsetting}\label{subsetting}

R's subsetting operators are powerful and fast. Mastery of subsetting
allows you to succinctly express complex operations in a way that few
other languages can match. Subsetting is hard to learn because you need
to master a number of interrelated concepts:

\begin{itemize}
\item
  The three subsetting operators.
\item
  The six types of subsetting.
\item
  Important differences in behaviour for different objects (e.g.,
  vectors, lists, factors, matrices, and data frames).
\item
  The use of subsetting in conjunction with assignment.
\end{itemize}

This chapter helps you master subsetting by starting with the simplest
type of subsetting: subsetting an atomic vector with \texttt{{[}}. It
then gradually extends your knowledge, first to more complicated data
types (like arrays and lists), and then to the other subsetting
operators, \texttt{{[}{[}} and \texttt{\$}. You'll then learn how
subsetting and assignment can be combined to modify parts of an object,
and, finally, you'll see a large number of useful applications.

Subsetting is a natural complement to \texttt{str()}. \texttt{str()}
shows you the structure of any object, and subsetting allows you to pull
out the pieces that you're interested in. \index{subsetting}

\paragraph{Quiz}

Take this short quiz to determine if you need to read this chapter. If
the answers quickly come to mind, you can comfortably skip this chapter.
Check your answers in \hyperref[subsetting-answers]{answers}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  What is the result of subsetting a vector with positive integers,
  negative integers, a logical vector, or a character vector?
\item
  What's the difference between \texttt{{[}}, \texttt{{[}{[}}, and
  \texttt{\$} when applied to a list?
\item
  When should you use \texttt{drop = FALSE}?
\item
  If \texttt{x} is a matrix, what does \texttt{x{[}{]} \textless{}- 0}
  do? How is it different to \texttt{x \textless{}- 0}?
\item
  How can you use a named vector to relabel categorical variables?
\end{enumerate}

\paragraph{Outline}

\begin{itemize}
\item
  \hyperref[data-types]{Data types} starts by teaching you about
  \texttt{{[}}. You'll start by learning the six types of data that you
  can use to subset atomic vectors. You'll then learn how those six data
  types act when used to subset lists, matrices, data frames, and S3
  objects.
\item
  \hyperref[subsetting-operators]{Subsetting operators} expands your
  knowledge of subsetting operators to include \texttt{{[}{[}} and
  \texttt{\$}, focussing on the important principles of simplifying
  vs.~preserving.
\item
  In \hyperref[subassignment]{Subsetting and assignment} you'll learn
  the art of subassignment, combining subsetting and assignment to
  modify parts of an object.
\item
  \hyperref[applications]{Applications} leads you through eight
  important, but not obvious, applications of subsetting to solve
  problems that you often encounter in a data analysis.
\end{itemize}

\hyperdef{}{data-types}{\section{Data types}\label{data-types}}

It's easiest to learn how subsetting works for atomic vectors, and then
how it generalises to higher dimensions and other more complicated
objects. We'll start with \texttt{{[}}, the most commonly used operator.
\hyperref[subsetting-operators]{Subsetting operators} will cover
\texttt{{[}{[}} and \texttt{\$}, the two other main subsetting
operators.

\subsection{Atomic vectors}

Let's explore the different types of subsetting with a simple vector,
\texttt{x}. \index{subsetting!atomic vectors}
\index{atomic vectors!subsetting} \indexc{[}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\FloatTok{2.1}\NormalTok{, }\FloatTok{4.2}\NormalTok{, }\FloatTok{3.3}\NormalTok{, }\FloatTok{5.4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Note that the number after the decimal point gives the original position
in the vector.

There are five things that you can use to subset a vector:

\begin{itemize}
\item
  \textbf{Positive integers} return elements at the specified positions:
  \index{subsetting!with positive integers}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{)]}
\CommentTok{#> [1] 3.3 2.1}
\NormalTok{x[}\KeywordTok{order}\NormalTok{(x)]}
\CommentTok{#> [1] 2.1 3.3 4.2 5.4}

\CommentTok{# Duplicated indices yield duplicated values}
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{)]}
\CommentTok{#> [1] 2.1 2.1}

\CommentTok{# Real numbers are silently truncated to integers}
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\FloatTok{2.1}\NormalTok{, }\FloatTok{2.9}\NormalTok{)]}
\CommentTok{#> [1] 4.2 4.2}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Negative integers} omit elements at the specified positions:
  \index{subsetting!with negative integers}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[-}\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{)]}
\CommentTok{#> [1] 4.2 5.4}
\end{Highlighting}
\end{Shaded}

  You can't mix positive and negative integers in a single subset:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\KeywordTok{c}\NormalTok{(-}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)]}
\CommentTok{#> Error in x[c(-1, 2)]: only 0's may be mixed with negative subscripts}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Logical vectors} select elements where the corresponding
  logical value is \texttt{TRUE}. This is probably the most useful type
  of subsetting because you write the expression that creates the
  logical vector: \index{subsetting!with logical vectors}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)]}
\CommentTok{#> [1] 2.1 4.2}
\NormalTok{x[x >}\StringTok{ }\DecValTok{3}\NormalTok{]}
\CommentTok{#> [1] 4.2 3.3 5.4}
\end{Highlighting}
\end{Shaded}

  If the logical vector is shorter than the vector being subsetted, it
  will be \emph{recycled} to be the same length.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)]}
\CommentTok{#> [1] 2.1 3.3}
\CommentTok{# Equivalent to}
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)]}
\CommentTok{#> [1] 2.1 3.3}
\end{Highlighting}
\end{Shaded}

  A missing value in the index always yields a missing value in the
  output:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)]}
\CommentTok{#> [1] 2.1 4.2  NA}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Nothing} returns the original vector. This is not useful for
  vectors but is very useful for matrices, data frames, and arrays. It
  can also be useful in conjunction with assignment.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[]}
\CommentTok{#> [1] 2.1 4.2 3.3 5.4}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Zero} returns a zero-length vector. This is not something you
  usually do on purpose, but it can be helpful for generating test data.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\DecValTok{0}\NormalTok{]}
\CommentTok{#> numeric(0)}
\end{Highlighting}
\end{Shaded}
\end{itemize}

If the vector is named, you can also use:

\begin{itemize}
\item
  \textbf{Character vectors} to return elements with matching names.
  \index{subsetting!with character vectors}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(y <-}\StringTok{ }\KeywordTok{setNames}\NormalTok{(x, letters[}\DecValTok{1}\NormalTok{:}\DecValTok{4}\NormalTok{]))}
\CommentTok{#>   a   b   c   d }
\CommentTok{#> 2.1 4.2 3.3 5.4}
\NormalTok{y[}\KeywordTok{c}\NormalTok{(}\StringTok{"d"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\StringTok{"a"}\NormalTok{)]}
\CommentTok{#>   d   c   a }
\CommentTok{#> 5.4 3.3 2.1}

\CommentTok{# Like integer indices, you can repeat indices}
\NormalTok{y[}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"a"}\NormalTok{, }\StringTok{"a"}\NormalTok{)]}
\CommentTok{#>   a   a   a }
\CommentTok{#> 2.1 2.1 2.1}

\CommentTok{# When subsetting with [ names are always matched exactly}
\NormalTok{z <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{abc =} \DecValTok{1}\NormalTok{, }\DataTypeTok{def =} \DecValTok{2}\NormalTok{)}
\NormalTok{z[}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"d"}\NormalTok{)]}
\CommentTok{#> <NA> <NA> }
\CommentTok{#>   NA   NA}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\subsection{Lists}

Subsetting a list works in the same way as subsetting an atomic vector.
Using \texttt{{[}} will always return a list; \texttt{{[}{[}} and
\texttt{\$}, as described below, let you pull out the components of the
list. \index{lists!subsetting} \index{subsetting!lists}

\subsection{Matrices and arrays}\label{matrix-subsetting}

You can subset higher-dimensional structures in three ways:
\index{subsetting!arrays} \index{arrays!subsetting}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  With multiple vectors.
\item
  With a single vector.
\item
  With a matrix.
\end{itemize}

The most common way of subsetting matrices (2d) and arrays
(\textgreater{}2d) is a simple generalisation of 1d subsetting: you
supply a 1d index for each dimension, separated by a comma. Blank
subsetting is now useful because it lets you keep all rows or all
columns.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{9}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{)}
\KeywordTok{colnames}\NormalTok{(a) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"A"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"C"}\NormalTok{)}
\NormalTok{a[}\DecValTok{1}\NormalTok{:}\DecValTok{2}\NormalTok{, ]}
\CommentTok{#>      A B C}
\CommentTok{#> [1,] 1 4 7}
\CommentTok{#> [2,] 2 5 8}
\NormalTok{a[}\KeywordTok{c}\NormalTok{(T, F, T), }\KeywordTok{c}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"A"}\NormalTok{)]}
\CommentTok{#>      B A}
\CommentTok{#> [1,] 4 1}
\CommentTok{#> [2,] 6 3}
\NormalTok{a[}\DecValTok{0}\NormalTok{, -}\DecValTok{2}\NormalTok{]}
\CommentTok{#>      A C}
\end{Highlighting}
\end{Shaded}

By default, \texttt{{[}} will simplify the results to the lowest
possible dimensionality. See \hyperref[simplify-preserve]{simplifying
vs.~preserving} to learn how to avoid this.

Because matrices and arrays are implemented as vectors with special
attributes, you can subset them with a single vector. In that case, they
will behave like a vector. Arrays in R are stored in column-major order:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(vals <-}\StringTok{ }\KeywordTok{outer}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{FUN =} \StringTok{"paste"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{","}\NormalTok{))}
\CommentTok{#>      [,1]  [,2]  [,3]  [,4]  [,5] }
\CommentTok{#> [1,] "1,1" "1,2" "1,3" "1,4" "1,5"}
\CommentTok{#> [2,] "2,1" "2,2" "2,3" "2,4" "2,5"}
\CommentTok{#> [3,] "3,1" "3,2" "3,3" "3,4" "3,5"}
\CommentTok{#> [4,] "4,1" "4,2" "4,3" "4,4" "4,5"}
\CommentTok{#> [5,] "5,1" "5,2" "5,3" "5,4" "5,5"}
\NormalTok{vals[}\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{15}\NormalTok{)]}
\CommentTok{#> [1] "4,1" "5,3"}
\end{Highlighting}
\end{Shaded}

You can also subset higher-dimensional data structures with an integer
matrix (or, if named, a character matrix). Each row in the matrix
specifies the location of one value, where each column corresponds to a
dimension in the array being subsetted. This means that you use a 2
column matrix to subset a matrix, a 3 column matrix to subset a 3d
array, and so on. The result is a vector of values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vals <-}\StringTok{ }\KeywordTok{outer}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{FUN =} \StringTok{"paste"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{","}\NormalTok{)}
\NormalTok{select <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DataTypeTok{ncol =} \DecValTok{2}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{TRUE}\NormalTok{, }\KeywordTok{c}\NormalTok{(}
  \DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{,}
  \DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{,}
  \DecValTok{2}\NormalTok{, }\DecValTok{4}
\NormalTok{))}
\NormalTok{vals[select]}
\CommentTok{#> [1] "1,1" "3,1" "2,4"}
\end{Highlighting}
\end{Shaded}

\subsection{Data frames}\label{df-subsetting}

Data frames possess the characteristics of both lists and matrices: if
you subset with a single vector, they behave like lists; if you subset
with two vectors, they behave like matrices.
\index{subsetting!data frames} \index{data frames!subsetting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{y =} \DecValTok{3}\NormalTok{:}\DecValTok{1}\NormalTok{, }\DataTypeTok{z =} \NormalTok{letters[}\DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{])}

\NormalTok{df[df$x ==}\StringTok{ }\DecValTok{2}\NormalTok{, ]}
\CommentTok{#>   x y z}
\CommentTok{#> 2 2 2 b}
\NormalTok{df[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{), ]}
\CommentTok{#>   x y z}
\CommentTok{#> 1 1 3 a}
\CommentTok{#> 3 3 1 c}

\CommentTok{# There are two ways to select columns from a data frame}
\CommentTok{# Like a list:}
\NormalTok{df[}\KeywordTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"z"}\NormalTok{)]}
\CommentTok{#>   x z}
\CommentTok{#> 1 1 a}
\CommentTok{#> 2 2 b}
\CommentTok{#> 3 3 c}
\CommentTok{# Like a matrix}
\NormalTok{df[, }\KeywordTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"z"}\NormalTok{)]}
\CommentTok{#>   x z}
\CommentTok{#> 1 1 a}
\CommentTok{#> 2 2 b}
\CommentTok{#> 3 3 c}

\CommentTok{# There's an important difference if you select a single }
\CommentTok{# column: matrix subsetting simplifies by default, list }
\CommentTok{# subsetting does not.}
\KeywordTok{str}\NormalTok{(df[}\StringTok{"x"}\NormalTok{])}
\CommentTok{#> 'data.frame':    3 obs. of  1 variable:}
\CommentTok{#>  $ x: int  1 2 3}
\KeywordTok{str}\NormalTok{(df[, }\StringTok{"x"}\NormalTok{])}
\CommentTok{#>  int [1:3] 1 2 3}
\end{Highlighting}
\end{Shaded}

\subsection{S3 objects}

S3 objects are made up of atomic vectors, arrays, and lists, so you can
always pull apart an S3 object using the techniques described above and
the knowledge you gain from \texttt{str()}. \index{subsetting!S3}
\index{S3!subsetting}

\subsection{S4 objects}

There are also two additional subsetting operators that are needed for
S4 objects: \texttt{@} (equivalent to \texttt{\$}), and \texttt{slot()}
(equivalent to \texttt{{[}{[}}). \texttt{@} is more restrictive than
\texttt{\$} in that it will return an error if the slot does not exist.
These are described in more detail in \hyperref[s4]{the OO field guide}.
\index{subsetting!S4} \index{S4!subsetting} \indexc{@}

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Fix each of the following common data frame subsetting errors:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[mtcars$cyl =}\StringTok{ }\DecValTok{4}\NormalTok{, ]}
\NormalTok{mtcars[-}\DecValTok{1}\NormalTok{:}\DecValTok{4}\NormalTok{, ]}
\NormalTok{mtcars[mtcars$cyl <=}\StringTok{ }\DecValTok{5}\NormalTok{]}
\NormalTok{mtcars[mtcars$cyl ==}\StringTok{ }\DecValTok{4} \NormalTok{|}\StringTok{ }\DecValTok{6}\NormalTok{, ]}
\end{Highlighting}
\end{Shaded}
\item
  Why does \texttt{x \textless{}- 1:5; x{[}NA{]}} yield five missing
  values? (Hint: why is it different from \texttt{x{[}NA\_real\_{]}}?)
\item
  What does \texttt{upper.tri()} return? How does subsetting a matrix
  with it work? Do we need any additional subsetting rules to describe
  its behaviour?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{outer}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{FUN =} \StringTok{"*"}\NormalTok{)}
\NormalTok{x[}\KeywordTok{upper.tri}\NormalTok{(x)]}
\end{Highlighting}
\end{Shaded}
\item
  Why does \texttt{mtcars{[}1:20{]}} return a error? How does it differ
  from the similar \texttt{mtcars{[}1:20, {]}}?
\item
  Implement your own function that extracts the diagonal entries from a
  matrix (it should behave like \texttt{diag(x)} where \texttt{x} is a
  matrix).
\item
  What does \texttt{df{[}is.na(df){]} \textless{}- 0} do? How does it
  work?
\end{enumerate}

\hyperdef{}{subsetting-operators}{\section{Subsetting
operators}\label{subsetting-operators}}

There are two other subsetting operators: \texttt{{[}{[}} and
\texttt{\$}. \texttt{{[}{[}} is similar to \texttt{{[}}, except it can
only return a single value and it allows you to pull pieces out of a
list. \texttt{\$} is a useful shorthand for \texttt{{[}{[}} combined
with character subsetting. \indexc{[[} \indexc{\$}

You need \texttt{{[}{[}} when working with lists. This is because when
\texttt{{[}} is applied to a list it always returns a list: it never
gives you the contents of the list. To get the contents, you need
\texttt{{[}{[}}:

\begin{quote}
``If list \texttt{x} is a train carrying objects, then
\texttt{x{[}{[}5{]}{]}} is the object in car 5; \texttt{x{[}4:6{]}} is a
train of cars 4-6.''

--- @RLangTip
\end{quote}

Because it can return only a single value, you must use \texttt{{[}{[}}
with either a single positive integer or a string:
\index{subsetting!lists} \index{lists!subsetting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{)}
\NormalTok{a[[}\DecValTok{1}\NormalTok{]]}
\CommentTok{#> [1] 1}
\NormalTok{a[[}\StringTok{"a"}\NormalTok{]]}
\CommentTok{#> [1] 1}

\CommentTok{# If you do supply a vector it indexes recursively}
\NormalTok{b <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{b =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{c =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{d =} \DecValTok{1}\NormalTok{))))}
\NormalTok{b[[}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\StringTok{"d"}\NormalTok{)]]}
\CommentTok{#> [1] 1}
\CommentTok{# Same as}
\NormalTok{b[[}\StringTok{"a"}\NormalTok{]][[}\StringTok{"b"}\NormalTok{]][[}\StringTok{"c"}\NormalTok{]][[}\StringTok{"d"}\NormalTok{]]}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

Because data frames are lists of columns, you can use \texttt{{[}{[}} to
extract a column from data frames: \texttt{mtcars{[}{[}1{]}{]}},
\texttt{mtcars{[}{[}"cyl"{]}{]}}. \index{subsetting!data frames}
\index{data frames!subsetting}

S3 and S4 objects can override the standard behaviour of \texttt{{[}}
and \texttt{{[}{[}} so they behave differently for different types of
objects. The key difference is usually how you select between
simplifying or preserving behaviours, and what the default is.

\hyperdef{}{simplify-preserve}{\subsection{Simplifying vs.~preserving
subsetting}\label{simplify-preserve}}

It's important to understand the distinction between simplifying and
preserving subsetting. Simplifying subsets returns the simplest possible
data structure that can represent the output, and is useful
interactively because it usually gives you what you want. Preserving
subsetting keeps the structure of the output the same as the input, and
is generally better for programming because the result will always be
the same type. Omitting \texttt{drop = FALSE} when subsetting matrices
and data frames is one of the most common sources of programming errors.
(It will work for your test cases, but then someone will pass in a
single column data frame and it will fail in an unexpected and unclear
way.) \indexc{drop = FALSE} \index{subsetting!simplifying}
\index{subsetting!preserving}

Unfortunately, how you switch between simplifying and preserving differs
for different data types, as summarised in the table below.

\begin{longtable}[c]{@{}lll@{}}
\toprule
& Simplifying & Preserving\tabularnewline
\midrule
\endhead
Vector & \texttt{x{[}{[}1{]}{]}} & \texttt{x{[}1{]}}\tabularnewline
List & \texttt{x{[}{[}1{]}{]}} & \texttt{x{[}1{]}}\tabularnewline
Factor & \texttt{x{[}1:4, drop = T{]}} &
\texttt{x{[}1:4{]}}\tabularnewline
Array & \texttt{x{[}1, {]}} \textbf{or} \texttt{x{[}, 1{]}} &
\texttt{x{[}1, , drop = F{]}} \textbf{or}
\texttt{x{[}, 1, drop = F{]}}\tabularnewline
Data frame & \texttt{x{[}, 1{]}} \textbf{or} \texttt{x{[}{[}1{]}{]}} &
\texttt{x{[}, 1, drop = F{]}} \textbf{or}
\texttt{x{[}1{]}}\tabularnewline
\bottomrule
\end{longtable}

Preserving is the same for all data types: you get the same type of
output as input. Simplifying behaviour varies slightly between different
data types, as described below:

\begin{itemize}
\item
  \textbf{Atomic vector}: removes names.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{)}
\NormalTok{x[}\DecValTok{1}\NormalTok{]}
\CommentTok{#> a }
\CommentTok{#> 1}
\NormalTok{x[[}\DecValTok{1}\NormalTok{]]}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{List}: return the object inside the list, not a single element
  list.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{)}
\KeywordTok{str}\NormalTok{(y[}\DecValTok{1}\NormalTok{])}
\CommentTok{#> List of 1}
\CommentTok{#>  $ a: num 1}
\KeywordTok{str}\NormalTok{(y[[}\DecValTok{1}\NormalTok{]])}
\CommentTok{#>  num 1}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Factor}: drops any unused levels.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{))}
\NormalTok{z[}\DecValTok{1}\NormalTok{]}
\CommentTok{#> [1] a}
\CommentTok{#> Levels: a b}
\NormalTok{z[}\DecValTok{1}\NormalTok{, drop =}\StringTok{ }\OtherTok{TRUE}\NormalTok{]}
\CommentTok{#> [1] a}
\CommentTok{#> Levels: a}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Matrix} or \textbf{array}: if any of the dimensions has length
  1, drops that dimension.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{4}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{2}\NormalTok{)}
\NormalTok{a[}\DecValTok{1}\NormalTok{, , drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
\CommentTok{#>      [,1] [,2]}
\CommentTok{#> [1,]    1    3}
\NormalTok{a[}\DecValTok{1}\NormalTok{, ]}
\CommentTok{#> [1] 1 3}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Data frame}: if output is a single column, returns a vector
  instead of a data frame.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{:}\DecValTok{2}\NormalTok{, }\DataTypeTok{b =} \DecValTok{1}\NormalTok{:}\DecValTok{2}\NormalTok{)}
\KeywordTok{str}\NormalTok{(df[}\DecValTok{1}\NormalTok{])}
\CommentTok{#> 'data.frame':    2 obs. of  1 variable:}
\CommentTok{#>  $ a: int  1 2}
\KeywordTok{str}\NormalTok{(df[[}\DecValTok{1}\NormalTok{]])}
\CommentTok{#>  int [1:2] 1 2}
\KeywordTok{str}\NormalTok{(df[, }\StringTok{"a"}\NormalTok{, }\DataTypeTok{drop =} \OtherTok{FALSE}\NormalTok{])}
\CommentTok{#> 'data.frame':    2 obs. of  1 variable:}
\CommentTok{#>  $ a: int  1 2}
\KeywordTok{str}\NormalTok{(df[, }\StringTok{"a"}\NormalTok{])}
\CommentTok{#>  int [1:2] 1 2}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\subsection{\texttt{\$}}

\texttt{\$} is a shorthand operator, where \texttt{x\$y} is equivalent
to \texttt{x{[}{[}"y", exact = FALSE{]}{]}}. It's often used to access
variables in a data frame, as in \texttt{mtcars\$cyl} or
\texttt{diamonds\$carat}. \indexc{\$} \indexc{[[}

One common mistake with \texttt{\$} is to try and use it when you have
the name of a column stored in a variable:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var <-}\StringTok{ "cyl"}
\CommentTok{# Doesn't work - mtcars$var translated to mtcars[["var"]]}
\NormalTok{mtcars$var}
\CommentTok{#> NULL}

\CommentTok{# Instead use [[}
\NormalTok{mtcars[[var]]}
\CommentTok{#>  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8}
\CommentTok{#> [30] 6 8 4}
\end{Highlighting}
\end{Shaded}

There's one important difference between \texttt{\$} and
\texttt{{[}{[}}. \texttt{\$} does partial matching:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{abc =} \DecValTok{1}\NormalTok{)}
\NormalTok{x$a}
\CommentTok{#> [1] 1}
\NormalTok{x[[}\StringTok{"a"}\NormalTok{]]}
\CommentTok{#> NULL}
\end{Highlighting}
\end{Shaded}

If you want to avoid this behaviour you can set the global option
\texttt{warnPartialMatchDollar} to \texttt{TRUE}. Use with caution: it
may affect behaviour in other code you have loaded (e.g., from a
package).

\subsection{Missing/out of bounds indices}

\texttt{{[}} and \texttt{{[}{[}} differ slightly in their behaviour when
the index is out of bounds (OOB), for example, when you try to extract
the fifth element of a length four vector, or subset a vector with
\texttt{NA} or \texttt{NULL}: \index{subsetting!with NA \& NULL}
\index{subsetting!out of bounds}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\NormalTok{:}\DecValTok{4}
\KeywordTok{str}\NormalTok{(x[}\DecValTok{5}\NormalTok{])}
\CommentTok{#>  int NA}
\KeywordTok{str}\NormalTok{(x[}\OtherTok{NA_real_}\NormalTok{])}
\CommentTok{#>  int NA}
\KeywordTok{str}\NormalTok{(x[}\OtherTok{NULL}\NormalTok{])}
\CommentTok{#>  int(0)}
\end{Highlighting}
\end{Shaded}

The following table summarises the results of subsetting atomic vectors
and lists with \texttt{{[}} and \texttt{{[}{[}} and different types of
OOB value.

\begin{longtable}[c]{@{}llll@{}}
\toprule
Operator & Index & Atomic & List\tabularnewline
\midrule
\endhead
\texttt{{[}} & OOB & \texttt{NA} & \texttt{list(NULL)}\tabularnewline
\texttt{{[}} & \texttt{NA\_real\_} & \texttt{NA} &
\texttt{list(NULL)}\tabularnewline
\texttt{{[}} & \texttt{NULL} & \texttt{x{[}0{]}} &
\texttt{list(NULL)}\tabularnewline
\texttt{{[}{[}} & OOB & Error & Error\tabularnewline
\texttt{{[}{[}} & \texttt{NA\_real\_} & Error &
\texttt{NULL}\tabularnewline
\texttt{{[}{[}} & \texttt{NULL} & Error & Error\tabularnewline
\bottomrule
\end{longtable}

If the input vector is named, then the names of OOB, missing, or
\texttt{NULL} components will be \texttt{"\textless{}NA\textgreater{}"}.

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Given a linear model, e.g.,
  \texttt{mod \textless{}- lm(mpg \textasciitilde{} wt, data = mtcars)},
  extract the residual degrees of freedom. Extract the R squared from
  the model summary (\texttt{summary(mod)})
\end{enumerate}

\hyperdef{}{subassignment}{\section{Subsetting and
assignment}\label{subassignment}}

All subsetting operators can be combined with assignment to modify
selected values of the input vector. \index{subsetting!subassignment}
\index{assignment!subassignment}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\NormalTok{:}\DecValTok{5}
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)] <-}\StringTok{ }\DecValTok{2}\NormalTok{:}\DecValTok{3}
\NormalTok{x}
\CommentTok{#> [1] 2 3 3 4 5}

\CommentTok{# The length of the LHS needs to match the RHS}
\NormalTok{x[-}\DecValTok{1}\NormalTok{] <-}\StringTok{ }\DecValTok{4}\NormalTok{:}\DecValTok{1}
\NormalTok{x}
\CommentTok{#> [1] 2 4 3 2 1}

\CommentTok{# Note that there's no checking for duplicate indices}
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{)] <-}\StringTok{ }\DecValTok{2}\NormalTok{:}\DecValTok{3}
\NormalTok{x}
\CommentTok{#> [1] 3 4 3 2 1}

\CommentTok{# You can't combine integer indices with NA}
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\OtherTok{NA}\NormalTok{)] <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\CommentTok{#> Error in x[c(1, NA)] <- c(1, 2): NAs are not allowed in subscripted assignments}
\CommentTok{# But you can combine logical indices with NA}
\CommentTok{# (where they're treated as false).}
\NormalTok{x[}\KeywordTok{c}\NormalTok{(T, F, }\OtherTok{NA}\NormalTok{)] <-}\StringTok{ }\DecValTok{1}
\NormalTok{x}
\CommentTok{#> [1] 1 4 3 1 1}

\CommentTok{# This is mostly useful when conditionally modifying vectors}
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{a =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\NormalTok{df$a[df$a <}\StringTok{ }\DecValTok{5}\NormalTok{] <-}\StringTok{ }\DecValTok{0}
\NormalTok{df$a}
\CommentTok{#> [1]  0 10 NA}
\end{Highlighting}
\end{Shaded}

Subsetting with nothing can be useful in conjunction with assignment
because it will preserve the original object class and structure.
Compare the following two expressions. In the first, \texttt{mtcars}
will remain as a data frame. In the second, \texttt{mtcars} will become
a list.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[] <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(mtcars, as.integer)}
\NormalTok{mtcars <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(mtcars, as.integer)}
\end{Highlighting}
\end{Shaded}

With lists, you can use subsetting + assignment + \texttt{NULL} to
remove components from a list. To add a literal \texttt{NULL} to a list,
use \texttt{{[}} and \texttt{list(NULL)}:
\index{lists!removing an element}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{)}
\NormalTok{x[[}\StringTok{"b"}\NormalTok{]] <-}\StringTok{ }\OtherTok{NULL}
\KeywordTok{str}\NormalTok{(x)}
\CommentTok{#> List of 1}
\CommentTok{#>  $ a: num 1}

\NormalTok{y <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{)}
\NormalTok{y[}\StringTok{"b"}\NormalTok{] <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\KeywordTok{str}\NormalTok{(y)}
\CommentTok{#> List of 2}
\CommentTok{#>  $ a: num 1}
\CommentTok{#>  $ b: NULL}
\end{Highlighting}
\end{Shaded}

\hyperdef{}{applications}{\section{Applications}\label{applications}}

The basic principles described above give rise to a wide variety of
useful applications. Some of the most important are described below.
Many of these basic techniques are wrapped up into more concise
functions (e.g., \texttt{subset()}, \texttt{merge()},
\texttt{plyr::arrange()}), but it is useful to understand how they are
implemented with basic subsetting. This will allow you to adapt to new
situations that are not dealt with by existing functions.

\subsection{Lookup tables (character subsetting)}\label{lookup-tables}

Character matching provides a powerful way to make lookup tables. Say
you want to convert abbreviations: \index{lookup tables}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"m"}\NormalTok{, }\StringTok{"f"}\NormalTok{, }\StringTok{"u"}\NormalTok{, }\StringTok{"f"}\NormalTok{, }\StringTok{"f"}\NormalTok{, }\StringTok{"m"}\NormalTok{, }\StringTok{"m"}\NormalTok{)}
\NormalTok{lookup <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{m =} \StringTok{"Male"}\NormalTok{, }\DataTypeTok{f =} \StringTok{"Female"}\NormalTok{, }\DataTypeTok{u =} \OtherTok{NA}\NormalTok{)}
\NormalTok{lookup[x]}
\CommentTok{#>        m        f        u        f        f        m }
\CommentTok{#>   "Male" "Female"       NA "Female" "Female"   "Male" }
\CommentTok{#>        m }
\CommentTok{#>   "Male"}
\KeywordTok{unname}\NormalTok{(lookup[x])}
\CommentTok{#> [1] "Male"   "Female" NA       "Female" "Female" "Male"  }
\CommentTok{#> [7] "Male"}

\CommentTok{# Or with fewer output values}
\KeywordTok{c}\NormalTok{(}\DataTypeTok{m =} \StringTok{"Known"}\NormalTok{, }\DataTypeTok{f =} \StringTok{"Known"}\NormalTok{, }\DataTypeTok{u =} \StringTok{"Unknown"}\NormalTok{)[x]}
\CommentTok{#>         m         f         u         f         f         m }
\CommentTok{#>   "Known"   "Known" "Unknown"   "Known"   "Known"   "Known" }
\CommentTok{#>         m }
\CommentTok{#>   "Known"}
\end{Highlighting}
\end{Shaded}

If you don't want names in the result, use \texttt{unname()} to remove
them.

\subsection{Matching and merging by hand (integer
subsetting)}\label{matching-merging}

You may have a more complicated lookup table which has multiple columns
of information. Suppose we have a vector of integer grades, and a table
that describes their properties: \index{matching \& merging}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{grades <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{)}

\NormalTok{info <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{grade =} \DecValTok{3}\NormalTok{:}\DecValTok{1}\NormalTok{,}
  \DataTypeTok{desc =} \KeywordTok{c}\NormalTok{(}\StringTok{"Excellent"}\NormalTok{, }\StringTok{"Good"}\NormalTok{, }\StringTok{"Poor"}\NormalTok{),}
  \DataTypeTok{fail =} \KeywordTok{c}\NormalTok{(F, F, T)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We want to duplicate the info table so that we have a row for each value
in \texttt{grades}. We can do this in two ways, either using
\texttt{match()} and integer subsetting, or \texttt{rownames()} and
character subsetting: \indexc{match()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{grades}
\CommentTok{#> [1] 1 2 2 3 1}

\CommentTok{# Using match}
\NormalTok{id <-}\StringTok{ }\KeywordTok{match}\NormalTok{(grades, info$grade)}
\NormalTok{info[id, ]}
\CommentTok{#>     grade      desc  fail}
\CommentTok{#> 3       1      Poor  TRUE}
\CommentTok{#> 2       2      Good FALSE}
\CommentTok{#> 2.1     2      Good FALSE}
\CommentTok{#> 1       3 Excellent FALSE}
\CommentTok{#> 3.1     1      Poor  TRUE}

\CommentTok{# Using rownames}
\KeywordTok{rownames}\NormalTok{(info) <-}\StringTok{ }\NormalTok{info$grade}
\NormalTok{info[}\KeywordTok{as.character}\NormalTok{(grades), ]}
\CommentTok{#>     grade      desc  fail}
\CommentTok{#> 1       1      Poor  TRUE}
\CommentTok{#> 2       2      Good FALSE}
\CommentTok{#> 2.1     2      Good FALSE}
\CommentTok{#> 3       3 Excellent FALSE}
\CommentTok{#> 1.1     1      Poor  TRUE}
\end{Highlighting}
\end{Shaded}

If you have multiple columns to match on, you'll need to first collapse
them to a single column (with \texttt{interaction()}, \texttt{paste()},
or \texttt{plyr::id()}). You can also use \texttt{merge()} or
\texttt{plyr::join()}, which do the same thing for you --- read the
source code to see how. \indexc{merge()}

\subsection{Random samples/bootstrap (integer subsetting)}

You can use integer indices to perform random sampling or bootstrapping
of a vector or data frame. \texttt{sample()} generates a vector of
indices, then subsetting to access the values: \indexc{sample()}
\index{sampling} \index{random sampling} \index{bootstrapping}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{rep}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{each =} \DecValTok{2}\NormalTok{), }\DataTypeTok{y =} \DecValTok{6}\NormalTok{:}\DecValTok{1}\NormalTok{, }\DataTypeTok{z =} \NormalTok{letters[}\DecValTok{1}\NormalTok{:}\DecValTok{6}\NormalTok{])}

\CommentTok{# Set seed for reproducibility}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{10}\NormalTok{)}

\CommentTok{# Randomly reorder}
\NormalTok{df[}\KeywordTok{sample}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(df)), ]}
\CommentTok{#>   x y z}
\CommentTok{#> 4 2 3 d}
\CommentTok{#> 2 1 5 b}
\CommentTok{#> 5 3 2 e}
\CommentTok{#> 3 2 4 c}
\CommentTok{#> 1 1 6 a}
\CommentTok{#> 6 3 1 f}
\CommentTok{# Select 3 random rows}
\NormalTok{df[}\KeywordTok{sample}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(df), }\DecValTok{3}\NormalTok{), ]}
\CommentTok{#>   x y z}
\CommentTok{#> 2 1 5 b}
\CommentTok{#> 6 3 1 f}
\CommentTok{#> 3 2 4 c}
\CommentTok{# Select 6 bootstrap replicates}
\NormalTok{df[}\KeywordTok{sample}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(df), }\DecValTok{6}\NormalTok{, }\DataTypeTok{rep =} \NormalTok{T), ]}
\CommentTok{#>     x y z}
\CommentTok{#> 3   2 4 c}
\CommentTok{#> 4   2 3 d}
\CommentTok{#> 4.1 2 3 d}
\CommentTok{#> 1   1 6 a}
\CommentTok{#> 4.2 2 3 d}
\CommentTok{#> 3.1 2 4 c}
\end{Highlighting}
\end{Shaded}

The arguments of \texttt{sample()} control the number of samples to
extract, and whether sampling is performed with or without replacement.

\subsection{Ordering (integer subsetting)}

\texttt{order()} takes a vector as input and returns an integer vector
describing how the subsetted vector should be ordered: \indexc{order()}
\index{sorting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\StringTok{"a"}\NormalTok{)}
\KeywordTok{order}\NormalTok{(x)}
\CommentTok{#> [1] 3 1 2}
\NormalTok{x[}\KeywordTok{order}\NormalTok{(x)]}
\CommentTok{#> [1] "a" "b" "c"}
\end{Highlighting}
\end{Shaded}

To break ties, you can supply additional variables to \texttt{order()},
and you can change from ascending to descending order using
\texttt{decreasing = TRUE}. By default, any missing values will be put
at the end of the vector; however, you can remove them with
\texttt{na.last = NA} or put at the front with \texttt{na.last = FALSE}.

For two or more dimensions, \texttt{order()} and integer subsetting
makes it easy to order either the rows or columns of an object:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Randomly reorder df}
\NormalTok{df2 <-}\StringTok{ }\NormalTok{df[}\KeywordTok{sample}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(df)), }\DecValTok{3}\NormalTok{:}\DecValTok{1}\NormalTok{]}
\NormalTok{df2}
\CommentTok{#>   z y x}
\CommentTok{#> 3 c 4 2}
\CommentTok{#> 1 a 6 1}
\CommentTok{#> 2 b 5 1}
\CommentTok{#> 4 d 3 2}
\CommentTok{#> 6 f 1 3}
\CommentTok{#> 5 e 2 3}

\NormalTok{df2[}\KeywordTok{order}\NormalTok{(df2$x), ]}
\CommentTok{#>   z y x}
\CommentTok{#> 1 a 6 1}
\CommentTok{#> 2 b 5 1}
\CommentTok{#> 3 c 4 2}
\CommentTok{#> 4 d 3 2}
\CommentTok{#> 6 f 1 3}
\CommentTok{#> 5 e 2 3}
\NormalTok{df2[, }\KeywordTok{order}\NormalTok{(}\KeywordTok{names}\NormalTok{(df2))]}
\CommentTok{#>   x y z}
\CommentTok{#> 3 2 4 c}
\CommentTok{#> 1 1 6 a}
\CommentTok{#> 2 1 5 b}
\CommentTok{#> 4 2 3 d}
\CommentTok{#> 6 3 1 f}
\CommentTok{#> 5 3 2 e}
\end{Highlighting}
\end{Shaded}

More concise, but less flexible, functions are available for sorting
vectors, \texttt{sort()}, and data frames, \texttt{plyr::arrange()}.
\indexc{sort()}

\subsection{Expanding aggregated counts (integer subsetting)}

Sometimes you get a data frame where identical rows have been collapsed
into one and a count column has been added. \texttt{rep()} and integer
subsetting make it easy to uncollapse the data by subsetting with a
repeated row index:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{1}\NormalTok{), }\DataTypeTok{y =} \KeywordTok{c}\NormalTok{(}\DecValTok{9}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{6}\NormalTok{), }\DataTypeTok{n =} \KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\NormalTok{:}\KeywordTok{nrow}\NormalTok{(df), df$n)}
\CommentTok{#> [1] 1 1 1 2 2 2 2 2 3}
\NormalTok{df[}\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\NormalTok{:}\KeywordTok{nrow}\NormalTok{(df), df$n), ]}
\CommentTok{#>     x  y n}
\CommentTok{#> 1   2  9 3}
\CommentTok{#> 1.1 2  9 3}
\CommentTok{#> 1.2 2  9 3}
\CommentTok{#> 2   4 11 5}
\CommentTok{#> 2.1 4 11 5}
\CommentTok{#> 2.2 4 11 5}
\CommentTok{#> 2.3 4 11 5}
\CommentTok{#> 2.4 4 11 5}
\CommentTok{#> 3   1  6 1}
\end{Highlighting}
\end{Shaded}

\subsection{Removing columns from data frames (character subsetting)}

There are two ways to remove columns from a data frame. You can set
individual columns to NULL: \index{data frames!remove columns}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{y =} \DecValTok{3}\NormalTok{:}\DecValTok{1}\NormalTok{, }\DataTypeTok{z =} \NormalTok{letters[}\DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{])}
\NormalTok{df$z <-}\StringTok{ }\OtherTok{NULL}
\end{Highlighting}
\end{Shaded}

Or you can subset to return only the columns you want:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{y =} \DecValTok{3}\NormalTok{:}\DecValTok{1}\NormalTok{, }\DataTypeTok{z =} \NormalTok{letters[}\DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{])}
\NormalTok{df[}\KeywordTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"y"}\NormalTok{)]}
\CommentTok{#>   x y}
\CommentTok{#> 1 1 3}
\CommentTok{#> 2 2 2}
\CommentTok{#> 3 3 1}
\end{Highlighting}
\end{Shaded}

If you know the columns you don't want, use set operations to work out
which colums to keep:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[}\KeywordTok{setdiff}\NormalTok{(}\KeywordTok{names}\NormalTok{(df), }\StringTok{"z"}\NormalTok{)]}
\CommentTok{#>   x y}
\CommentTok{#> 1 1 3}
\CommentTok{#> 2 2 2}
\CommentTok{#> 3 3 1}
\end{Highlighting}
\end{Shaded}

\subsection{Selecting rows based on a condition (logical subsetting)}

Because it allows you to easily combine conditions from multiple
columns, logical subsetting is probably the most commonly used technique
for extracting rows out of a data frame.
\index{subsetting!with logical vectors}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[mtcars$gear ==}\StringTok{ }\DecValTok{5}\NormalTok{, ]}
\CommentTok{#>     mpg cyl  disp  hp drat   wt qsec vs am gear carb}
\CommentTok{#> 27 26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2}
\CommentTok{#> 28 30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2}
\CommentTok{#> 29 15.8   8 351.0 264 4.22 3.17 14.5  0  1    5    4}
\CommentTok{#> 30 19.7   6 145.0 175 3.62 2.77 15.5  0  1    5    6}
\CommentTok{#> 31 15.0   8 301.0 335 3.54 3.57 14.6  0  1    5    8}
\NormalTok{mtcars[mtcars$gear ==}\StringTok{ }\DecValTok{5} \NormalTok{&}\StringTok{ }\NormalTok{mtcars$cyl ==}\StringTok{ }\DecValTok{4}\NormalTok{, ]}
\CommentTok{#>     mpg cyl  disp  hp drat   wt qsec vs am gear carb}
\CommentTok{#> 27 26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2}
\CommentTok{#> 28 30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2}
\end{Highlighting}
\end{Shaded}

Remember to use the vector boolean operators \texttt{\&} and
\texttt{\textbar{}}, not the short-circuiting scalar operators
\texttt{\&\&} and \texttt{\textbar{}\textbar{}} which are more useful
inside if statements. Don't forget
\href{http://en.wikipedia.org/wiki/De_Morgan's_laws}{De Morgan's laws},
which can be useful to simplify negations:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{!(X \& Y)} is the same as \texttt{!X \textbar{} !Y}
\item
  \texttt{!(X \textbar{} Y)} is the same as \texttt{!X \& !Y}
\end{itemize}

For example, \texttt{!(X \& !(Y \textbar{} Z))} simplifies to
\texttt{!X \textbar{} !!(Y\textbar{}Z)}, and then to
\texttt{!X \textbar{} Y \textbar{} Z}.

\texttt{subset()} is a specialised shorthand function for subsetting
data frames, and saves some typing because you don't need to repeat the
name of the data frame. You'll learn how it works in
\hyperref[nse]{non-standard evaluation}. \indexc{subset()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{subset}\NormalTok{(mtcars, gear ==}\StringTok{ }\DecValTok{5}\NormalTok{)}
\CommentTok{#>     mpg cyl  disp  hp drat   wt qsec vs am gear carb}
\CommentTok{#> 27 26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2}
\CommentTok{#> 28 30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2}
\CommentTok{#> 29 15.8   8 351.0 264 4.22 3.17 14.5  0  1    5    4}
\CommentTok{#> 30 19.7   6 145.0 175 3.62 2.77 15.5  0  1    5    6}
\CommentTok{#> 31 15.0   8 301.0 335 3.54 3.57 14.6  0  1    5    8}
\KeywordTok{subset}\NormalTok{(mtcars, gear ==}\StringTok{ }\DecValTok{5} \NormalTok{&}\StringTok{ }\NormalTok{cyl ==}\StringTok{ }\DecValTok{4}\NormalTok{)}
\CommentTok{#>     mpg cyl  disp  hp drat   wt qsec vs am gear carb}
\CommentTok{#> 27 26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2}
\CommentTok{#> 28 30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2}
\end{Highlighting}
\end{Shaded}

\subsection{Boolean algebra vs.~sets (logical \& integer subsetting)}

It's useful to be aware of the natural equivalence between set
operations (integer subsetting) and boolean algebra (logical
subsetting). Using set operations is more effective when:
\index{Boolean algebra} \index{set algebra}

\begin{itemize}
\item
  You want to find the first (or last) \texttt{TRUE}.
\item
  You have very few \texttt{TRUE}s and very many \texttt{FALSE}s; a set
  representation may be faster and require less storage.
\end{itemize}

\texttt{which()} allows you to convert a boolean representation to an
integer representation. There's no reverse operation in base R but we
can easily create one: \indexc{which()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DecValTok{10}\NormalTok{) <}\StringTok{ }\DecValTok{4}
\KeywordTok{which}\NormalTok{(x)}
\CommentTok{#> [1]  3  7 10}

\NormalTok{unwhich <-}\StringTok{ }\NormalTok{function(x, n) \{}
  \NormalTok{out <-}\StringTok{ }\KeywordTok{rep_len}\NormalTok{(}\OtherTok{FALSE}\NormalTok{, n)}
  \NormalTok{out[x] <-}\StringTok{ }\OtherTok{TRUE}
  \NormalTok{out}
\NormalTok{\}}
\KeywordTok{unwhich}\NormalTok{(}\KeywordTok{which}\NormalTok{(x), }\DecValTok{10}\NormalTok{)}
\CommentTok{#>  [1] FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE}
\CommentTok{#> [10]  TRUE}
\end{Highlighting}
\end{Shaded}

Let's create two logical vectors and their integer equivalents and then
explore the relationship between boolean and set operations.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(x1 <-}\StringTok{ }\DecValTok{1}\NormalTok{:}\DecValTok{10} \NormalTok{%%}\StringTok{ }\DecValTok{2} \NormalTok{==}\StringTok{ }\DecValTok{0}\NormalTok{)}
\CommentTok{#>  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE}
\CommentTok{#> [10]  TRUE}
\NormalTok{(x2 <-}\StringTok{ }\KeywordTok{which}\NormalTok{(x1))}
\CommentTok{#> [1]  2  4  6  8 10}
\NormalTok{(y1 <-}\StringTok{ }\DecValTok{1}\NormalTok{:}\DecValTok{10} \NormalTok{%%}\StringTok{ }\DecValTok{5} \NormalTok{==}\StringTok{ }\DecValTok{0}\NormalTok{)}
\CommentTok{#>  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE}
\CommentTok{#> [10]  TRUE}
\NormalTok{(y2 <-}\StringTok{ }\KeywordTok{which}\NormalTok{(y1))}
\CommentTok{#> [1]  5 10}

\CommentTok{# X & Y <-> intersect(x, y)}
\NormalTok{x1 &}\StringTok{ }\NormalTok{y1}
\CommentTok{#>  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE}
\CommentTok{#> [10]  TRUE}
\KeywordTok{intersect}\NormalTok{(x2, y2)}
\CommentTok{#> [1] 10}

\CommentTok{# X | Y <-> union(x, y)}
\NormalTok{x1 |}\StringTok{ }\NormalTok{y1}
\CommentTok{#>  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE}
\CommentTok{#> [10]  TRUE}
\KeywordTok{union}\NormalTok{(x2, y2)}
\CommentTok{#> [1]  2  4  6  8 10  5}

\CommentTok{# X & !Y <-> setdiff(x, y)}
\NormalTok{x1 &}\StringTok{ }\NormalTok{!y1}
\CommentTok{#>  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE}
\CommentTok{#> [10] FALSE}
\KeywordTok{setdiff}\NormalTok{(x2, y2)}
\CommentTok{#> [1] 2 4 6 8}

\CommentTok{# xor(X, Y) <-> setdiff(union(x, y), intersect(x, y))}
\KeywordTok{xor}\NormalTok{(x1, y1)}
\CommentTok{#>  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE}
\CommentTok{#> [10] FALSE}
\KeywordTok{setdiff}\NormalTok{(}\KeywordTok{union}\NormalTok{(x2, y2), }\KeywordTok{intersect}\NormalTok{(x2, y2))}
\CommentTok{#> [1] 2 4 6 8 5}
\end{Highlighting}
\end{Shaded}

When first learning subsetting, a common mistake is to use
\texttt{x{[}which(y){]}} instead of \texttt{x{[}y{]}}. Here the
\texttt{which()} achieves nothing: it switches from logical to integer
subsetting but the result will be exactly the same. Also beware that
\texttt{x{[}-which(y){]}} is \textbf{not} equivalent to
\texttt{x{[}!y{]}}: if \texttt{y} is all FALSE, \texttt{which(y)} will
be \texttt{integer(0)} and \texttt{-integer(0)} is still
\texttt{integer(0)}, so you'll get no values, instead of all values. In
general, avoid switching from logical to integer subsetting unless you
want, for example, the first or last \texttt{TRUE} value.

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  How would you randomly permute the columns of a data frame? (This is
  an important technique in random forests.) Can you simultaneously
  permute the rows and columns in one step?
\item
  How would you select a random sample of \texttt{m} rows from a data
  frame? What if the sample had to be contiguous (i.e., with an initial
  row, a final row, and every row in between)?
\item
  How could you put the columns in a data frame in alphabetical order?
\end{enumerate}

\hyperdef{}{subsetting-answers}{\section{Answers}\label{subsetting-answers}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Positive integers select elements at specific positions, negative
  integers drop elements; logical vectors keep elements at positions
  corresponding to \texttt{TRUE}; character vectors select elements with
  matching names.
\item
  \texttt{{[}} selects sub-lists. It always returns a list; if you use
  it with a single positive integer, it returns a list of length one.
  \texttt{{[}{[}} selects an element within a list. \texttt{\$} is a
  convenient shorthand: \texttt{x\$y} is equivalent to
  \texttt{x{[}{[}"y"{]}{]}}.
\item
  Use \texttt{drop = FALSE} if you are subsetting a matrix, array, or
  data frame and you want to preserve the original dimensions. You
  should almost always use it when subsetting inside a function.
\item
  If \texttt{x} is a matrix, \texttt{x{[}{]} \textless{}- 0} will
  replace every element with 0, keeping the same number of rows and
  columns. \texttt{x \textless{}- 0} completely replaces the matrix with
  the value 0.
\item
  A named character vector can act as a simple lookup table:
  \texttt{c(x = 1, y = 2, z = 3){[}c("y", "z", "x"){]}}
\end{enumerate}
