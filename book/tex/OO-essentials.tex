\chapter{OO field guide}\label{oo}

This chapter is a field guide for recognising and working with R's
objects in the wild. R has three object oriented systems (plus the base
types), so it can be a bit intimidating. The goal of this guide is not
to make you an expert in all four systems, but to help you identify
which system you're working with and to help you use it effectively.
\index{object-oriented programming}

Central to any object-oriented system are the concepts of class and
method. A \textbf{class} defines the behaviour of \textbf{objects} by
describing their attributes and their relationship to other classes. The
class is also used when selecting \textbf{methods}, functions that
behave differently depending on the class of their input. Classes are
usually organised in a hierarchy: if a method does not exist for a
child, then the parent's method is used instead; the child
\textbf{inherits} behaviour from the parent.

R's three OO systems differ in how classes and methods are defined:

\begin{itemize}
\item
  \textbf{S3} implements a style of OO programming called
  generic-function OO. This is different from most programming
  languages, like Java, C++, and C\#, which implement message-passing
  OO. With message-passing, messages (methods) are sent to objects and
  the object determines which function to call. Typically, this object
  has a special appearance in the method call, usually appearing before
  the name of the method/message: e.g.,
  \texttt{canvas.drawRect("blue")}. S3 is different. While computations
  are still carried out via methods, a special type of function called a
  \textbf{generic function} decides which method to call, e.g.,
  \texttt{drawRect(canvas, "blue")}. S3 is a very casual system. It has
  no formal definition of classes.
\item
  \textbf{S4} works similarly to S3, but is more formal. There are two
  major differences to S3. S4 has formal class definitions, which
  describe the representation and inheritance for each class, and has
  special helper functions for defining generics and methods. S4 also
  has multiple dispatch, which means that generic functions can pick
  methods based on the class of any number of arguments, not just one.
\item
  \textbf{Reference classes}, called RC for short, are quite different
  from S3 and S4. RC implements message-passing OO, so methods belong to
  classes, not functions. \texttt{\$} is used to separate objects and
  methods, so method calls look like \texttt{canvas\$drawRect("blue")}.
  RC objects are also mutable: they don't use R's usual copy-on-modify
  semantics, but are modified in place. This makes them harder to reason
  about, but allows them to solve problems that are difficult to solve
  with S3 or S4.
\end{itemize}

There's also one other system that's not quite OO, but it's important to
mention here:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \textbf{base types}, the internal C-level types that underlie the
  other OO systems. Base types are mostly manipulated using C code, but
  they're important to know about because they provide the building
  blocks for the other OO systems.
\end{itemize}

The following sections describe each system in turn, starting with base
types. You'll learn how to recognise the OO system that an object
belongs to, how method dispatch works, and how to create new objects,
classes, generics, and methods for that system. The chapter concludes
with a few remarks on when to use each system.

\paragraph{Prerequisites}

You'll need the pryr package, \texttt{install.packages("pryr")}, to
access useful functions for examining OO properties.

\paragraph{Quiz}

Think you know this material already? If you can answer the following
questions correctly, you can safely skip this chapter. Find the answers
at the end of the chapter in \hyperref[oo-answers]{answers}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  How do you tell what OO system (base, S3, S4, or RC) an object is
  associated with?
\item
  How do you determine the base type (like integer or list) of an
  object?
\item
  What is a generic function?
\item
  What are the main differences between S3 and S4? What are the main
  differences between S4 \& RC?
\end{enumerate}

\paragraph{Outline}

\begin{itemize}
\item
  \hyperref[base-types]{Base types} teaches you about R's base object
  system. Only R-core can add new classes to this system, but it's
  important to know about because it underpins the three other systems.
\item
  \hyperref[s3]{S3} shows you the basics of the S3 object system. It's
  the simplest and most commonly used OO system.
\item
  \hyperref[s4]{S4} discusses the more formal and rigorous S4 system.
\item
  \hyperref[rc]{RC} teaches you about R's newest OO system: reference
  classes, or RC for short.
\item
  \hyperref[picking-a-system]{Picking a system} advises on which OO
  system to use if you're starting a new project.
\end{itemize}

\hyperdef{}{base-types}{\section{Base types}\label{base-types}}

Underlying every R object is a C structure (or struct) that describes
how that object is stored in memory. The struct includes the contents of
the object, the information needed for memory management, and, most
importantly for this section, a \textbf{type}. This is the \textbf{base
type} of an R object. Base types are not really an object system because
only the R core team can create new types. As a result, new base types
are added very rarely: the most recent change, in 2011, added two exotic
types that you never see in R, but are useful for diagnosing memory
problems (\texttt{NEWSXP} and \texttt{FREESXP}). Prior to that, the last
type added was a special base type for S4 objects (\texttt{S4SXP}) in
2005. \indexc{SEXP} \index{base types} \index{objects!base types}

\hyperref[data-structures]{Data structures} explains the most common
base types (atomic vectors and lists), but base types also encompass
functions, environments, and other more exotic objects likes names,
calls, and promises that you'll learn about later in the book. You can
determine an object's base type with \texttt{typeof()}. Unfortunately
the names of base types are not used consistently throughout R, and type
and the corresponding ``is'' function may use different names:
\indexc{typeof()}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# The type of a function is "closure"}
\NormalTok{f <-}\StringTok{ }\NormalTok{function() \{\}}
\KeywordTok{typeof}\NormalTok{(f)}
\CommentTok{#> [1] "closure"}
\KeywordTok{is.function}\NormalTok{(f)}
\CommentTok{#> [1] TRUE}

\CommentTok{# The type of a primitive function is "builtin"}
\KeywordTok{typeof}\NormalTok{(sum)}
\CommentTok{#> [1] "builtin"}
\KeywordTok{is.primitive}\NormalTok{(sum)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

You may have heard of \texttt{mode()} and \texttt{storage.mode()}. I
recommend ignoring these functions because they're just aliases of the
names returned by \texttt{typeof()}, and exist solely for S
compatibility. Read their source code if you want to understand exactly
what they do. \indexc{mode()}

Functions that behave differently for different base types are almost
always written in C, where dispatch occurs using switch statements
(e.g., \texttt{switch(TYPEOF(x))}). Even if you never write C code, it's
important to understand base types because everything else is built on
top of them: S3 objects can be built on top of any base type, S4 objects
use a special base type, and RC objects are a combination of S4 and
environments (another base type). To see if an object is a pure base
type, i.e., it doesn't also have S3, S4, or RC behaviour, check that
\texttt{is.object(x)} returns \texttt{FALSE}.

\hyperdef{}{s3}{\section{S3}\label{s3}}

S3 is R's first and simplest OO system. It is the only OO system used in
the base and stats packages, and it's the most commonly used system in
CRAN packages. S3 is informal and ad hoc, but it has a certain elegance
in its minimalism: you can't take away any part of it and still have a
useful OO system. \index{S3} \index{objects!S3|see{S3}}

\subsection{Recognising objects, generic functions, and methods}

Most objects that you encounter are S3 objects. But unfortunately
there's no simple way to test if an object is an S3 object in base R.
The closest you can come is \texttt{is.object(x) \& !isS4(x)}, i.e.,
it's an object, but not S4. An easier way is to use
\texttt{pryr::otype()}: \indexc{otype()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(pryr)}

\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{y =} \NormalTok{letters[}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{])}
\KeywordTok{otype}\NormalTok{(df)    }\CommentTok{# A data frame is an S3 class}
\CommentTok{#> [1] "S3"}
\KeywordTok{otype}\NormalTok{(df$x)  }\CommentTok{# A numeric vector isn't}
\CommentTok{#> [1] "base"}
\KeywordTok{otype}\NormalTok{(df$y)  }\CommentTok{# A factor is}
\CommentTok{#> [1] "S3"}
\end{Highlighting}
\end{Shaded}

In S3, methods belong to functions, called \textbf{generic functions},
or generics for short. S3 methods do not belong to objects or classes.
This is different from most other programming languages, but is a
legitimate OO style. \index{functions!generics|see{generics}}
\index{S3!generics} \index{generics!S3}

To determine if a function is an S3 generic, you can inspect its source
code for a call to \texttt{UseMethod()}: that's the function that
figures out the correct method to call, the process of \textbf{method
dispatch}. Similar to \texttt{otype()}, pryr also provides
\texttt{ftype()} which describes the object system, if any, associated
with a function: \indexc{UseMethod()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mean}
\CommentTok{#> function (x, ...) }
\CommentTok{#> UseMethod("mean")}
\CommentTok{#> <bytecode: 0x7fb0b6295878>}
\CommentTok{#> <environment: namespace:base>}
\KeywordTok{ftype}\NormalTok{(mean)}
\CommentTok{#> [1] "s3"      "generic"}
\end{Highlighting}
\end{Shaded}

Some S3 generics, like \texttt{{[}}, \texttt{sum()}, and
\texttt{cbind()}, don't call \texttt{UseMethod()} because they are
implemented in C. Instead, they call the C functions
\texttt{DispatchGroup()} or \texttt{DispatchOrEval()}. Functions that do
method dispatch in C code are called \textbf{internal generics} and are
documented in \texttt{?"internal generic"}. \texttt{ftype()} knows about
these special cases too.

Given a class, the job of an S3 generic is to call the right S3 method.
You can recognise S3 methods by their names, which look like
\texttt{generic.class()}. For example, the Date method for the
\texttt{mean()} generic is called \texttt{mean.Date()}, and the factor
method for \texttt{print()} is called \texttt{print.factor()}.
\index{methods!S3} \index{S3!methods}

This is the reason that most modern style guides discourage the use of
\texttt{.} in function names: it makes them look like S3 methods. For
example, is \texttt{t.test()} the \texttt{test} method for \texttt{t}
objects? Similarly, the use of \texttt{.} in class names can also be
confusing: is \texttt{print.data.frame()} the \texttt{print()} method
for \texttt{data.frames}, or the \texttt{print.data()} method for
\texttt{frames}? \texttt{pryr::ftype()} knows about these exceptions, so
you can use it to figure out if a function is an S3 method or generic:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ftype}\NormalTok{(t.data.frame) }\CommentTok{# data frame method for t()}
\CommentTok{#> [1] "s3"     "method"}
\KeywordTok{ftype}\NormalTok{(t.test)       }\CommentTok{# generic function for t tests}
\CommentTok{#> [1] "s3"      "generic"}
\end{Highlighting}
\end{Shaded}

You can see all the methods that belong to a generic with
\texttt{methods()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{methods}\NormalTok{(}\StringTok{"mean"}\NormalTok{)}
\CommentTok{#> [1] mean.Date     mean.default  mean.difftime mean.POSIXct }
\CommentTok{#> [5] mean.POSIXlt}
\KeywordTok{methods}\NormalTok{(}\StringTok{"t.test"}\NormalTok{)}
\CommentTok{#> [1] t.test.default* t.test.formula*}
\CommentTok{#> }
\CommentTok{#>    Non-visible functions are asterisked}
\end{Highlighting}
\end{Shaded}

(Apart from methods defined in the base package, most S3 methods will
not be visible: use \texttt{getS3method()} to read their source code.)

You can also list all generics that have a method for a given class:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{methods}\NormalTok{(}\DataTypeTok{class =} \StringTok{"ts"}\NormalTok{)}
\CommentTok{#>  [1] [.ts*            [<-.ts*          aggregate.ts    }
\CommentTok{#>  [4] as.data.frame.ts cbind.ts*        cycle.ts*       }
\CommentTok{#>  [7] diff.ts*         diffinv.ts*      kernapply.ts*   }
\CommentTok{#> [10] lines.ts*        monthplot.ts*    na.omit.ts*     }
\CommentTok{#> [13] Ops.ts*          plot.ts          print.ts*       }
\CommentTok{#> [16] t.ts*            time.ts*         window.ts*      }
\CommentTok{#> [19] window<-.ts*    }
\CommentTok{#> }
\CommentTok{#>    Non-visible functions are asterisked}
\end{Highlighting}
\end{Shaded}

There's no way to list all S3 classes, as you'll learn in the following
section.

\subsection{Defining classes and creating objects}

S3 is a simple and ad hoc system; it has no formal definition of a
class. To make an object an instance of a class, you just take an
existing base object and set the class attribute. You can do that during
creation with \texttt{structure()}, or after the fact with
\texttt{class\textless{}-()}: \index{S3!classes} \index{classes!S3}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Create and assign class in one step}
\NormalTok{foo <-}\StringTok{ }\KeywordTok{structure}\NormalTok{(}\KeywordTok{list}\NormalTok{(), }\DataTypeTok{class =} \StringTok{"foo"}\NormalTok{)}

\CommentTok{# Create, then set class}
\NormalTok{foo <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\KeywordTok{class}\NormalTok{(foo) <-}\StringTok{ "foo"}
\end{Highlighting}
\end{Shaded}

S3 objects are usually built on top of lists, or atomic vectors with
attributes. (You can refresh your memory of attributes with
\hyperref[attributes]{attributes}.) You can also turn functions into S3
objects. Other base types are either rarely seen in R, or have unusual
semantics that don't work well with attributes.

You can determine the class of any object using \texttt{class(x)}, and
see if an object inherits from a specific class using
\texttt{inherits(x, "classname")}. \index{attributes!class}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(foo)}
\CommentTok{#> [1] "foo"}
\KeywordTok{inherits}\NormalTok{(foo, }\StringTok{"foo"}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

The class of an S3 object can be a vector, which describes behaviour
from most to least specific. For example, the class of the
\texttt{glm()} object is \texttt{c("glm", "lm")} indicating that
generalised linear models inherit behaviour from linear models. Class
names are usually lower case, and you should avoid \texttt{.}.
Otherwise, opinion is mixed whether to use underscores
(\texttt{my\_class}) or CamelCase (\texttt{MyClass}) for multi-word
class names.

Most S3 classes provide a constructor function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{foo <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{if (!}\KeywordTok{is.numeric}\NormalTok{(x)) }\KeywordTok{stop}\NormalTok{(}\StringTok{"X must be numeric"}\NormalTok{)}
  \KeywordTok{structure}\NormalTok{(}\KeywordTok{list}\NormalTok{(x), }\DataTypeTok{class =} \StringTok{"foo"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

You should use it if it's available (like for \texttt{factor()} and
\texttt{data.frame()}). This ensures that you're creating the class with
the correct components. Constructor functions usually have the same name
as the class.

Apart from developer supplied constructor functions, S3 has no checks
for correctness. This means you can change the class of existing
objects:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Create a linear model}
\NormalTok{mod <-}\StringTok{ }\KeywordTok{lm}\NormalTok{(}\KeywordTok{log}\NormalTok{(mpg) ~}\StringTok{ }\KeywordTok{log}\NormalTok{(disp), }\DataTypeTok{data =} \NormalTok{mtcars)}
\KeywordTok{class}\NormalTok{(mod)}
\CommentTok{#> [1] "lm"}
\KeywordTok{print}\NormalTok{(mod)}
\CommentTok{#> }
\CommentTok{#> Call:}
\CommentTok{#> lm(formula = log(mpg) ~ log(disp), data = mtcars)}
\CommentTok{#> }
\CommentTok{#> Coefficients:}
\CommentTok{#> (Intercept)    log(disp)  }
\CommentTok{#>       5.381       -0.459}

\CommentTok{# Turn it into a data frame (?!)}
\KeywordTok{class}\NormalTok{(mod) <-}\StringTok{ "data.frame"}
\CommentTok{# But unsurprisingly this doesn't work very well}
\KeywordTok{print}\NormalTok{(mod)}
\CommentTok{#>  [1] coefficients  residuals     effects       rank         }
\CommentTok{#>  [5] fitted.values assign        qr            df.residual  }
\CommentTok{#>  [9] xlevels       call          terms         model        }
\CommentTok{#> <0 rows> (or 0-length row.names)}
\CommentTok{# However, the data is still there}
\NormalTok{mod$coefficients}
\CommentTok{#> (Intercept)   log(disp) }
\CommentTok{#>       5.381      -0.459}
\end{Highlighting}
\end{Shaded}

If you've used other OO languages, this might make you feel queasy. But
surprisingly, this flexibility causes few problems: while you \emph{can}
change the type of an object, you never should. R doesn't protect you
from yourself: you can easily shoot yourself in the foot. As long as you
don't aim the gun at your foot and pull the trigger, you won't have a
problem.

\subsection{Creating new methods and generics}

To add a new generic, create a function that calls \texttt{UseMethod()}.
\texttt{UseMethod()} takes two arguments: the name of the generic
function, and the argument to use for method dispatch. If you omit the
second argument it will dispatch on the first argument to the function.
There's no need to pass any of the arguments of the generic to
\texttt{UseMethod()} and you shouldn't do so. \texttt{UseMethod()} uses
black magic to find them out for itself. \indexc{UseMethod()}
\index{S3!new generic}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function(x) }\KeywordTok{UseMethod}\NormalTok{(}\StringTok{"f"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

A generic isn't useful without some methods. To add a method, you just
create a regular function with the correct (\texttt{generic.class})
name: \index{S3!new methods}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f.a <-}\StringTok{ }\NormalTok{function(x) }\StringTok{"Class a"}

\NormalTok{a <-}\StringTok{ }\KeywordTok{structure}\NormalTok{(}\KeywordTok{list}\NormalTok{(), }\DataTypeTok{class =} \StringTok{"a"}\NormalTok{)}
\KeywordTok{class}\NormalTok{(a)}
\CommentTok{#> [1] "a"}
\KeywordTok{f}\NormalTok{(a)}
\CommentTok{#> [1] "Class a"}
\end{Highlighting}
\end{Shaded}

Adding a method to an existing generic works in the same way:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mean.a <-}\StringTok{ }\NormalTok{function(x) }\StringTok{"a"}
\KeywordTok{mean}\NormalTok{(a)}
\CommentTok{#> [1] "a"}
\end{Highlighting}
\end{Shaded}

As you can see, there's no check to make sure that the method returns
the class compatible with the generic. It's up to you to make sure that
your method doesn't violate the expectations of existing code.

\subsection{Method dispatch}

S3 method dispatch is relatively simple. \texttt{UseMethod()} creates a
vector of function names, like
\texttt{paste0("generic", ".", c(class(x), "default"))} and looks for
each in turn. The ``default'' class makes it possible to set up a fall
back method for otherwise unknown classes.
\index{S3!method dispatch rules}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function(x) }\KeywordTok{UseMethod}\NormalTok{(}\StringTok{"f"}\NormalTok{)}
\NormalTok{f.a <-}\StringTok{ }\NormalTok{function(x) }\StringTok{"Class a"}
\NormalTok{f.default <-}\StringTok{ }\NormalTok{function(x) }\StringTok{"Unknown class"}

\KeywordTok{f}\NormalTok{(}\KeywordTok{structure}\NormalTok{(}\KeywordTok{list}\NormalTok{(), }\DataTypeTok{class =} \StringTok{"a"}\NormalTok{))}
\CommentTok{#> [1] "Class a"}
\CommentTok{# No method for b class, so uses method for a class}
\KeywordTok{f}\NormalTok{(}\KeywordTok{structure}\NormalTok{(}\KeywordTok{list}\NormalTok{(), }\DataTypeTok{class =} \KeywordTok{c}\NormalTok{(}\StringTok{"b"}\NormalTok{, }\StringTok{"a"}\NormalTok{)))}
\CommentTok{#> [1] "Class a"}
\CommentTok{# No method for c class, so falls back to default}
\KeywordTok{f}\NormalTok{(}\KeywordTok{structure}\NormalTok{(}\KeywordTok{list}\NormalTok{(), }\DataTypeTok{class =} \StringTok{"c"}\NormalTok{))}
\CommentTok{#> [1] "Unknown class"}
\end{Highlighting}
\end{Shaded}

Group generic methods add a little more complexity. Group generics make
it possible to implement methods for multiple generics with one
function. The four group generics and the functions they include are:
\index{group generics} \index{S3!group generics}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Math: \texttt{abs}, \texttt{sign}, \texttt{sqrt}, \texttt{floor},
  \texttt{cos}, \texttt{sin}, \texttt{log}, \texttt{exp}, \ldots{}
\item
  Ops: \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{\^{}},
  \texttt{\%\%}, \texttt{\%/\%}, \texttt{\&}, \texttt{\textbar{}},
  \texttt{!}, \texttt{==}, \texttt{!=}, \texttt{\textless{}},
  \texttt{\textless{}=}, \texttt{\textgreater{}=},
  \texttt{\textgreater{}}
\item
  Summary: \texttt{all}, \texttt{any}, \texttt{sum}, \texttt{prod},
  \texttt{min}, \texttt{max}, \texttt{range}
\item
  Complex: \texttt{Arg}, \texttt{Conj}, \texttt{Im}, \texttt{Mod},
  \texttt{Re}
\end{itemize}

Group generics are a relatively advanced technique and are beyond the
scope of this chapter but you can find out more about them in
\texttt{?groupGeneric}. The most important thing to take away from this
is to recognise that \texttt{Math}, \texttt{Ops}, \texttt{Summary}, and
\texttt{Complex} aren't real functions, but instead represent groups of
functions. Note that inside a group generic function a special variable
\texttt{.Generic} provides the actual generic function called.

If you have complex class hierarchies it's sometimes useful to call the
``parent'' method. It's a little bit tricky to define exactly what that
means, but it's basically the method that would have been called if the
current method did not exist. Again, this is an advanced technique: you
can read about it in \texttt{?NextMethod}. \indexc{NextMethod()}

Because methods are normal R functions, you can call them directly:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{c <-}\StringTok{ }\KeywordTok{structure}\NormalTok{(}\KeywordTok{list}\NormalTok{(), }\DataTypeTok{class =} \StringTok{"c"}\NormalTok{)}
\CommentTok{# Call the correct method:}
\KeywordTok{f.default}\NormalTok{(c)}
\CommentTok{#> [1] "Unknown class"}
\CommentTok{# Force R to call the wrong method:}
\KeywordTok{f.a}\NormalTok{(c)}
\CommentTok{#> [1] "Class a"}
\end{Highlighting}
\end{Shaded}

However, this is just as dangerous as changing the class of an object,
so you shouldn't do it. Please don't point the loaded gun at your foot!
The only reason to call the method directly is that sometimes you can
get considerable performance improvements by skipping method dispatch.
See \hyperref[be-lazy]{performance} for details.

You can also call an S3 generic with a non-S3 object. Non-internal S3
generics will dispatch on the \textbf{implicit class} of base types.
(Internal generics don't do that for performance reasons.) The rules to
determine the implicit class of a base type are somewhat complex, but
are shown in the function below: \index{implicit class}
\index{base types!implicit class}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iclass <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{if (}\KeywordTok{is.object}\NormalTok{(x)) \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"x is not a primitive type"}\NormalTok{, }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
  \NormalTok{\}}

  \KeywordTok{c}\NormalTok{(}
    \NormalTok{if (}\KeywordTok{is.matrix}\NormalTok{(x)) }\StringTok{"matrix"}\NormalTok{,}
    \NormalTok{if (}\KeywordTok{is.array}\NormalTok{(x) &&}\StringTok{ }\NormalTok{!}\KeywordTok{is.matrix}\NormalTok{(x)) }\StringTok{"array"}\NormalTok{,}
    \NormalTok{if (}\KeywordTok{is.double}\NormalTok{(x)) }\StringTok{"double"}\NormalTok{,}
    \NormalTok{if (}\KeywordTok{is.integer}\NormalTok{(x)) }\StringTok{"integer"}\NormalTok{,}
    \KeywordTok{mode}\NormalTok{(x)}
  \NormalTok{)}
\NormalTok{\}}
\KeywordTok{iclass}\NormalTok{(}\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{5}\NormalTok{))}
\CommentTok{#> [1] "matrix"  "integer" "numeric"}
\KeywordTok{iclass}\NormalTok{(}\KeywordTok{array}\NormalTok{(}\FloatTok{1.5}\NormalTok{))}
\CommentTok{#> [1] "array"   "double"  "numeric"}
\end{Highlighting}
\end{Shaded}

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Read the source code for \texttt{t()} and \texttt{t.test()} and
  confirm that \texttt{t.test()} is an S3 generic and not an S3 method.
  What happens if you create an object with class \texttt{test} and call
  \texttt{t()} with it?
\item
  What classes have a method for the \texttt{Math} group generic in base
  R? Read the source code. How do the methods work?
\item
  R has two classes for representing date time data, \texttt{POSIXct}
  and \texttt{POSIXlt}, which both inherit from \texttt{POSIXt}. Which
  generics have different behaviours for the two classes? Which generics
  share the same behaviour?
\item
  Which base generic has the greatest number of defined methods?
\item
  \texttt{UseMethod()} calls methods in a special way. Predict what the
  following code will return, then run it and read the help for
  \texttt{UseMethod()} to figure out what's going on. Write down the
  rules in the simplest form possible.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\DecValTok{1}
\NormalTok{g <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{y <-}\StringTok{ }\DecValTok{2}
  \KeywordTok{UseMethod}\NormalTok{(}\StringTok{"g"}\NormalTok{)}
\NormalTok{\}}
\NormalTok{g.numeric <-}\StringTok{ }\NormalTok{function(x) y}
\KeywordTok{g}\NormalTok{(}\DecValTok{10}\NormalTok{)}

\NormalTok{h <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{x <-}\StringTok{ }\DecValTok{10}
  \KeywordTok{UseMethod}\NormalTok{(}\StringTok{"h"}\NormalTok{)}
\NormalTok{\}}
\NormalTok{h.character <-}\StringTok{ }\NormalTok{function(x) }\KeywordTok{paste}\NormalTok{(}\StringTok{"char"}\NormalTok{, x)}
\NormalTok{h.numeric <-}\StringTok{ }\NormalTok{function(x) }\KeywordTok{paste}\NormalTok{(}\StringTok{"num"}\NormalTok{, x)}

\KeywordTok{h}\NormalTok{(}\StringTok{"a"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\item
  Internal generics don't dispatch on the implicit class of base types.
  Carefully read \texttt{?"internal generic"} to determine why the
  length of \texttt{f} and \texttt{g} is different in the example below.
  What function helps distinguish between the behaviour of \texttt{f}
  and \texttt{g}?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function() }\DecValTok{1}
\NormalTok{g <-}\StringTok{ }\NormalTok{function() }\DecValTok{2}
\KeywordTok{class}\NormalTok{(g) <-}\StringTok{ "function"}

\KeywordTok{class}\NormalTok{(f)}
\KeywordTok{class}\NormalTok{(g)}

\NormalTok{length.function <-}\StringTok{ }\NormalTok{function(x) }\StringTok{"function"}
\KeywordTok{length}\NormalTok{(f)}
\KeywordTok{length}\NormalTok{(g)}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hyperdef{}{s4}{\section{S4}\label{s4}}

S4 works in a similar way to S3, but it adds formality and rigour.
Methods still belong to functions, not classes, but:
\index{objects!S4|see{S4}} \index{S4}

\begin{itemize}
\item
  Classes have formal definitions which describe their fields and
  inheritance structures (parent classes).
\item
  Method dispatch can be based on multiple arguments to a generic
  function, not just one.
\item
  There is a special operator, \texttt{@}, for extracting slots (aka
  fields) from an S4 object.
\end{itemize}

All S4 related code is stored in the \texttt{methods} package. This
package is always available when you're running R interactively, but may
not be available when running R in batch mode. For this reason, it's a
good idea to include an explicit \texttt{library(methods)} whenever
you're using S4.

S4 is a rich and complex system. There's no way to explain it fully in a
few pages. Here I'll focus on the key ideas underlying S4 so you can use
existing S4 objects effectively. To learn more, some good references
are:

\begin{itemize}
\item
  \href{http://www.bioconductor.org/help/course-materials/2010/AdvancedR/S4InBioconductor.pdf}{S4
  system development in Bioconductor}
\item
  John Chambers'
  \href{http://amzn.com/0387759352?tag=devtools-20}{\emph{Software for
  Data Analysis}}
\item
  \href{http://stackoverflow.com/search?tab=votes\&q=user\%3a547331\%20\%5bs4\%5d\%20is\%3aanswe}{Martin
  Morgan's answers to S4 questions on stackoverflow}
\end{itemize}

\subsection{Recognising objects, generic functions, and methods}

Recognising S4 objects, generics, and methods is easy. You can identify
an S4 object because \texttt{str()} describes it as a ``formal'' class,
\texttt{isS4()} returns \texttt{TRUE}, and \texttt{pryr::otype()}
returns ``S4''. S4 generics and methods are also easy to identify
because they are S4 objects with well defined classes.

There aren't any S4 classes in the commonly used base packages (stats,
graphics, utils, datasets, and base), so we'll start by creating an S4
object from the built-in stats4 package, which provides some S4 classes
and methods associated with maximum likelihood estimation:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(stats4)}

\CommentTok{# From example(mle)}
\NormalTok{y <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{26}\NormalTok{, }\DecValTok{17}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{8}\NormalTok{)}
\NormalTok{nLL <-}\StringTok{ }\NormalTok{function(lambda) -}\StringTok{ }\KeywordTok{sum}\NormalTok{(}\KeywordTok{dpois}\NormalTok{(y, lambda, }\DataTypeTok{log =} \OtherTok{TRUE}\NormalTok{))}
\NormalTok{fit <-}\StringTok{ }\KeywordTok{mle}\NormalTok{(nLL, }\DataTypeTok{start =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{lambda =} \DecValTok{5}\NormalTok{), }\DataTypeTok{nobs =} \KeywordTok{length}\NormalTok{(y))}

\CommentTok{# An S4 object}
\KeywordTok{isS4}\NormalTok{(fit)}
\CommentTok{#> [1] TRUE}
\KeywordTok{otype}\NormalTok{(fit)}
\CommentTok{#> [1] "S4"}

\CommentTok{# An S4 generic}
\KeywordTok{isS4}\NormalTok{(nobs)}
\CommentTok{#> [1] TRUE}
\KeywordTok{ftype}\NormalTok{(nobs)}
\CommentTok{#> [1] "s4"      "generic"}

\CommentTok{# Retrieve an S4 method, described later}
\NormalTok{mle_nobs <-}\StringTok{ }\KeywordTok{method_from_call}\NormalTok{(}\KeywordTok{nobs}\NormalTok{(fit))}
\KeywordTok{isS4}\NormalTok{(mle_nobs)}
\CommentTok{#> [1] TRUE}
\KeywordTok{ftype}\NormalTok{(mle_nobs)}
\CommentTok{#> [1] "s4"     "method"}
\end{Highlighting}
\end{Shaded}

Use \texttt{is()} with one argument to list all classes that an object
inherits from. Use \texttt{is()} with two arguments to test if an object
inherits from a specific class.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is}\NormalTok{(fit)}
\CommentTok{#> [1] "mle"}
\KeywordTok{is}\NormalTok{(fit, }\StringTok{"mle"}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

You can get a list of all S4 generics with \texttt{getGenerics()}, and a
list of all S4 classes with \texttt{getClasses()}. This list includes
shim classes for S3 classes and base types. You can list all S4 methods
with \texttt{showMethods()}, optionally restricting selection either by
\texttt{generic} or by \texttt{class} (or both). It's also a good idea
to supply \texttt{where = search()} to restrict the search to methods
available in the global environment.

\subsection{Defining classes and creating objects}

In S3, you can turn any object into an object of a particular class just
by setting the class attribute. S4 is much stricter: you must define the
representation of a class with \texttt{setClass()}, and create a new
object with \texttt{new()}. You can find the documentation for a class
with a special syntax: \texttt{class?className}, e.g.,
\texttt{class?mle}. \index{S4!classes} \index{classes!S4}

An S4 class has three key properties:

\begin{itemize}
\item
  A \textbf{name}: an alpha-numeric class identifier. By convention, S4
  class names use UpperCamelCase.
\item
  A named list of \textbf{slots} (fields), which defines slot names and
  permitted classes. For example, a person class might be represented by
  a character name and a numeric age:
  \texttt{list(name = "character", age = "numeric")}. \index{slots}
\item
  A string giving the class it inherits from, or, in S4 terminology,
  that it \textbf{contains}. You can provide multiple classes for
  multiple inheritance, but this is an advanced technique which adds
  much complexity.
\end{itemize}

In \texttt{slots} and \texttt{contains} you can use S4 classes, S3
classes registered with \texttt{setOldClass()}, or the implicit class of
a base type. In \texttt{slots} you can also use the special class
\texttt{ANY} which does not restrict the input.

S4 classes have other optional properties like a \texttt{validity}
method that tests if an object is valid, and a \texttt{prototype} object
that defines default slot values. See \texttt{?setClass} for more
details.

The following example creates a Person class with fields name and age,
and an Employee class that inherits from Person. The Employee class
inherits the slots and methods from the Person, and adds an additional
slot, boss. To create objects we call \texttt{new()} with the name of
the class, and name-value pairs of slot values. \indexc{setClass()}
\indexc{new()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Person"}\NormalTok{,}
  \DataTypeTok{slots =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{name =} \StringTok{"character"}\NormalTok{, }\DataTypeTok{age =} \StringTok{"numeric"}\NormalTok{))}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Employee"}\NormalTok{,}
  \DataTypeTok{slots =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{boss =} \StringTok{"Person"}\NormalTok{),}
  \DataTypeTok{contains =} \StringTok{"Person"}\NormalTok{)}

\NormalTok{alice <-}\StringTok{ }\KeywordTok{new}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }\DataTypeTok{name =} \StringTok{"Alice"}\NormalTok{, }\DataTypeTok{age =} \DecValTok{40}\NormalTok{)}
\NormalTok{john <-}\StringTok{ }\KeywordTok{new}\NormalTok{(}\StringTok{"Employee"}\NormalTok{, }\DataTypeTok{name =} \StringTok{"John"}\NormalTok{, }\DataTypeTok{age =} \DecValTok{20}\NormalTok{, }\DataTypeTok{boss =} \NormalTok{alice)}
\end{Highlighting}
\end{Shaded}

Most S4 classes also come with a constructor function with the same name
as the class: if that exists, use it instead of calling \texttt{new()}
directly.

To access slots of an S4 object use \texttt{@} or \texttt{slot()}:
\index{subsetting!S4} \index{S4|subsetting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{alice@age}
\CommentTok{#> [1] 40}
\KeywordTok{slot}\NormalTok{(john, }\StringTok{"boss"}\NormalTok{)}
\CommentTok{#> An object of class "Person"}
\CommentTok{#> Slot "name":}
\CommentTok{#> [1] "Alice"}
\CommentTok{#> }
\CommentTok{#> Slot "age":}
\CommentTok{#> [1] 40}
\end{Highlighting}
\end{Shaded}

(\texttt{@} is equivalent to \texttt{\$}, and \texttt{slot()} to
\texttt{{[}{[}}.)

If an S4 object contains (inherits from) an S3 class or a base type, it
will have a special \texttt{.Data} slot which contains the underlying
base type or S3 object: \indexc{.Data}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"RangedNumeric"}\NormalTok{,}
  \DataTypeTok{contains =} \StringTok{"numeric"}\NormalTok{,}
  \DataTypeTok{slots =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{min =} \StringTok{"numeric"}\NormalTok{, }\DataTypeTok{max =} \StringTok{"numeric"}\NormalTok{))}
\NormalTok{rn <-}\StringTok{ }\KeywordTok{new}\NormalTok{(}\StringTok{"RangedNumeric"}\NormalTok{, }\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{min =} \DecValTok{1}\NormalTok{, }\DataTypeTok{max =} \DecValTok{10}\NormalTok{)}
\NormalTok{rn@min}
\CommentTok{#> [1] 1}
\NormalTok{rn@.Data}
\CommentTok{#>  [1]  1  2  3  4  5  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

Since R is an interactive programming language, it's possible to create
new classes or redefine existing classes at any time. This can be a
problem when you're interactively experimenting with S4. If you modify a
class, make sure you also recreate any objects of that class, otherwise
you'll end up with invalid objects.

\subsection{Creating new methods and generics}

S4 provides special functions for creating new generics and methods.
\texttt{setGeneric()} creates a new generic or converts an existing
function into a generic. \texttt{setMethod()} takes the name of the
generic, the classes the method should be associated with, and a
function that implements the method. For example, we could take
\texttt{union()}, which usually just works on vectors, and make it work
with data frames: \index{S4!generics} \index{S4!methods}
\index{generics!S4} \index{methods!S4}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"union"}\NormalTok{)}
\CommentTok{#> [1] "union"}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"union"}\NormalTok{,}
  \KeywordTok{c}\NormalTok{(}\DataTypeTok{x =} \StringTok{"data.frame"}\NormalTok{, }\DataTypeTok{y =} \StringTok{"data.frame"}\NormalTok{),}
  \NormalTok{function(x, y) \{}
    \KeywordTok{unique}\NormalTok{(}\KeywordTok{rbind}\NormalTok{(x, y))}
  \NormalTok{\}}
\NormalTok{)}
\CommentTok{#> [1] "union"}
\end{Highlighting}
\end{Shaded}

If you create a new generic from scratch, you need to supply a function
that calls \texttt{standardGeneric()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"myGeneric"}\NormalTok{, function(x) \{}
  \KeywordTok{standardGeneric}\NormalTok{(}\StringTok{"myGeneric"}\NormalTok{)}
\NormalTok{\})}
\CommentTok{#> [1] "myGeneric"}
\end{Highlighting}
\end{Shaded}

\texttt{standardGeneric()} is the S4 equivalent to \texttt{UseMethod()}.

\subsection{Method dispatch}

If an S4 generic dispatches on a single class with a single parent, then
S4 method dispatch is the same as S3 dispatch. The main difference is
how you set up default values: S4 uses the special class \texttt{ANY} to
match any class and ``missing'' to match a missing argument. Like S3, S4
also has group generics, documented in \texttt{?S4groupGeneric}, and a
way to call the ``parent'' method, \texttt{callNextMethod()}.
\index{S4!method dispatch rules}

Method dispatch becomes considerably more complicated if you dispatch on
multiple arguments, or if your classes use multiple inheritance. The
rules are described in \texttt{?Methods}, but they are complicated and
it's difficult to predict which method will be called. For this reason,
I strongly recommend avoiding multiple inheritance and multiple dispatch
unless absolutely necessary.

Finally, there are two methods that find which method gets called given
the specification of a generic call:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# From methods: takes generic name and class names}
\KeywordTok{selectMethod}\NormalTok{(}\StringTok{"nobs"}\NormalTok{, }\KeywordTok{list}\NormalTok{(}\StringTok{"mle"}\NormalTok{))}

\CommentTok{# From pryr: takes an unevaluated function call}
\KeywordTok{method_from_call}\NormalTok{(}\KeywordTok{nobs}\NormalTok{(fit))}
\end{Highlighting}
\end{Shaded}

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Which S4 generic has the most methods defined for it? Which S4 class
  has the most methods associated with it?
\item
  What happens if you define a new S4 class that doesn't ``contain'' an
  existing class? (Hint: read about virtual classes in
  \texttt{?Classes}.)
\item
  What happens if you pass an S4 object to an S3 generic? What happens
  if you pass an S3 object to an S4 generic? (Hint: read
  \texttt{?setOldClass} for the second case.)
\end{enumerate}

\hyperdef{}{rc}{\section{RC}\label{rc}}

Reference classes (or RC for short) are the newest OO system in R. They
were introduced in version 2.12. They are fundamentally different to S3
and S4 because: \index{RC} \index{reference classes|see{RC}}
\index{objects!RC|see{RC}}

\begin{itemize}
\item
  RC methods belong to objects, not functions
\item
  RC objects are mutable: the usual R copy-on-modify semantics do not
  apply
\end{itemize}

These properties make RC objects behave more like objects do in most
other programming languages, e.g., Python, Ruby, Java, and C\#.
Reference classes are implemented using R code: they are a special S4
class that wraps around an environment.

\subsection{Defining classes and creating objects}

Since there aren't any reference classes provided by the base R
packages, we'll start by creating one. RC classes are best used for
describing stateful objects, objects that change over time, so we'll
create a simple class to model a bank account. \index{RC!classes}
\index{classes!RC}

Creating a new RC class is similar to creating a new S4 class, but you
use \texttt{setRefClass()} instead of \texttt{setClass()}. The first,
and only required argument, is an alphanumeric \textbf{name}. While you
can use \texttt{new()} to create new RC objects, it's good style to use
the object returned by \texttt{setRefClass()} to generate new objects.
(You can also do that with S4 classes, but it's less common.)
\indexc{setRefClass()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Account <-}\StringTok{ }\KeywordTok{setRefClass}\NormalTok{(}\StringTok{"Account"}\NormalTok{)}
\NormalTok{Account$}\KeywordTok{new}\NormalTok{()}
\CommentTok{#> Reference class object of class "Account"}
\end{Highlighting}
\end{Shaded}

\texttt{setRefClass()} also accepts a list of name-class pairs that
define class \textbf{fields} (equivalent to S4 slots). Additional named
arguments passed to \texttt{new()} will set initial values of the
fields. You can get and set field values with \texttt{\$}:
\index{fields}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Account <-}\StringTok{ }\KeywordTok{setRefClass}\NormalTok{(}\StringTok{"Account"}\NormalTok{,}
  \DataTypeTok{fields =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{balance =} \StringTok{"numeric"}\NormalTok{))}

\NormalTok{a <-}\StringTok{ }\NormalTok{Account$}\KeywordTok{new}\NormalTok{(}\DataTypeTok{balance =} \DecValTok{100}\NormalTok{)}
\NormalTok{a$balance}
\CommentTok{#> [1] 100}
\NormalTok{a$balance <-}\StringTok{ }\DecValTok{200}
\NormalTok{a$balance}
\CommentTok{#> [1] 200}
\end{Highlighting}
\end{Shaded}

Instead of supplying a class name for the field, you can provide a
single argument function which will act as an accessor method. This
allows you to add custom behaviour when getting or setting a field. See
\texttt{?setRefClass} for more details.

Note that RC objects are \textbf{mutable}, i.e., they have reference
semantics, and are not copied-on-modify:
\index{copy-on-modify!exceptions}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b <-}\StringTok{ }\NormalTok{a}
\NormalTok{b$balance}
\CommentTok{#> [1] 200}
\NormalTok{a$balance <-}\StringTok{ }\DecValTok{0}
\NormalTok{b$balance}
\CommentTok{#> [1] 0}
\end{Highlighting}
\end{Shaded}

For this reason, RC objects come with a \texttt{copy()} method that
allow you to make a copy of the object:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{c <-}\StringTok{ }\NormalTok{a$}\KeywordTok{copy}\NormalTok{()}
\NormalTok{c$balance}
\CommentTok{#> [1] 0}
\NormalTok{a$balance <-}\StringTok{ }\DecValTok{100}
\NormalTok{c$balance}
\CommentTok{#> [1] 0}
\end{Highlighting}
\end{Shaded}

An object is not very useful without some behaviour defined by
\textbf{methods}. RC methods are associated with a class and can modify
its fields in place. In the following example, note that you access the
value of fields with their name, and modify them with
\texttt{\textless{}\textless{}-}. You'll learn more about
\texttt{\textless{}\textless{}-} in \hyperref[binding]{Environments}.
\index{RC!methods} \index{methods!RC} \indexc{<<-}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Account <-}\StringTok{ }\KeywordTok{setRefClass}\NormalTok{(}\StringTok{"Account"}\NormalTok{,}
  \DataTypeTok{fields =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{balance =} \StringTok{"numeric"}\NormalTok{),}
  \DataTypeTok{methods =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{withdraw =} \NormalTok{function(x) \{}
      \NormalTok{balance <<-}\StringTok{ }\NormalTok{balance -}\StringTok{ }\NormalTok{x}
    \NormalTok{\},}
    \DataTypeTok{deposit =} \NormalTok{function(x) \{}
      \NormalTok{balance <<-}\StringTok{ }\NormalTok{balance +}\StringTok{ }\NormalTok{x}
    \NormalTok{\}}
  \NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You call an RC method in the same way as you access a field:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\NormalTok{Account$}\KeywordTok{new}\NormalTok{(}\DataTypeTok{balance =} \DecValTok{100}\NormalTok{)}
\NormalTok{a$}\KeywordTok{deposit}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\NormalTok{a$balance}
\CommentTok{#> [1] 200}
\end{Highlighting}
\end{Shaded}

The final important argument to \texttt{setRefClass()} is
\texttt{contains}. This is the name of the parent RC class to inherit
behaviour from. The following example creates a new type of bank account
that returns an error preventing the balance from going below 0.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{NoOverdraft <-}\StringTok{ }\KeywordTok{setRefClass}\NormalTok{(}\StringTok{"NoOverdraft"}\NormalTok{,}
  \DataTypeTok{contains =} \StringTok{"Account"}\NormalTok{,}
  \DataTypeTok{methods =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{withdraw =} \NormalTok{function(x) \{}
      \NormalTok{if (balance <}\StringTok{ }\NormalTok{x) }\KeywordTok{stop}\NormalTok{(}\StringTok{"Not enough money"}\NormalTok{)}
      \NormalTok{balance <<-}\StringTok{ }\NormalTok{balance -}\StringTok{ }\NormalTok{x}
    \NormalTok{\}}
  \NormalTok{)}
\NormalTok{)}
\NormalTok{accountJohn <-}\StringTok{ }\NormalTok{NoOverdraft$}\KeywordTok{new}\NormalTok{(}\DataTypeTok{balance =} \DecValTok{100}\NormalTok{)}
\NormalTok{accountJohn$}\KeywordTok{deposit}\NormalTok{(}\DecValTok{50}\NormalTok{)}
\NormalTok{accountJohn$balance}
\CommentTok{#> [1] 150}
\NormalTok{accountJohn$}\KeywordTok{withdraw}\NormalTok{(}\DecValTok{200}\NormalTok{)}
\CommentTok{#> Error in accountJohn$withdraw(200): Not enough money}
\end{Highlighting}
\end{Shaded}

All reference classes eventually inherit from \texttt{envRefClass}. It
provides useful methods like \texttt{copy()} (shown above),
\texttt{callSuper()} (to call the parent field), \texttt{field()} (to
get the value of a field given its name), \texttt{export()} (equivalent
to \texttt{as()}), and \texttt{show()} (overridden to control printing).
See the inheritance section in \texttt{setRefClass()} for more details.

\subsection{Recognising objects and methods}

You can recognise RC objects because they are S4 objects
(\texttt{isS4(x)}) that inherit from ``refClass''
(\texttt{is(x, "refClass")}). \texttt{pryr::otype()} will return ``RC''.
RC methods are also S4 objects, with class \texttt{refMethodDef}.

\subsection{Method dispatch}

Method dispatch is very simple in RC because methods are associated with
classes, not functions. When you call \texttt{x\$f()}, R will look for a
method f in the class of x, then in its parent, then its parent's
parent, and so on. From within a method, you can call the parent method
directly with \texttt{callSuper(...)}. \index{RC!method dispatch rules}

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Use a field function to prevent the account balance from being
  directly manipulated. (Hint: create a ``hidden'' \texttt{.balance}
  field, and read the help for the fields argument in
  \texttt{setRefClass()}.)
\item
  I claimed that there aren't any RC classes in base R, but that was a
  bit of a simplification. Use \texttt{getClasses()} and find which
  classes \texttt{extend()} from \texttt{envRefClass}. What are the
  classes used for? (Hint: recall how to look up the documentation for a
  class.)
\end{enumerate}

\hyperdef{}{picking-a-system}{\section{Picking a
system}\label{picking-a-system}}

Three OO systems is a lot for one language, but for most R programming,
S3 suffices. In R you usually create fairly simple objects and methods
for pre-existing generic functions like \texttt{print()},
\texttt{summary()}, and \texttt{plot()}. S3 is well suited to this task,
and the majority of OO code that I have written in R is S3. S3 is a
little quirky, but it gets the job done with a minimum of code.
\index{objects!which system?}

If you are creating more complicated systems of interrelated objects, S4
may be more appropriate. A good example is the \texttt{Matrix} package
by Douglas Bates and Martin Maechler. It is designed to efficiently
store and compute with many different types of sparse matrices. As of
version 1.1.3, it defines 102 classes and 20 generic functions. The
package is well written and well commented, and the accompanying
vignette (\texttt{vignette("Intro2Matrix", package = "Matrix")}) gives a
good overview of the structure of the package. S4 is also used
extensively by Bioconductor packages, which need to model complicated
interrelationships between biological objects. Bioconductor provides
many \href{https://www.google.com/search?q=bioconductor+s4}{good
resources} for learning S4. If you've mastered S3, S4 is relatively easy
to pick up; the ideas are all the same, it is just more formal, more
strict, and more verbose.

If you've programmed in a mainstream OO language, RC will seem very
natural. But because they can introduce side effects through mutable
state, they are harder to understand. For example, when you usually call
\texttt{f(a, b)} in R you can assume that \texttt{a} and \texttt{b} will
not be modified. But if \texttt{a} and \texttt{b} are RC objects, they
might be modified in the place. Generally, when using RC objects you
want to minimise side effects as much as possible, and use them only
where mutable states are absolutely required. The majority of functions
should still be ``functional'', and free of side effects. This makes
code easier to reason about and easier for other R programmers to
understand.

\hyperdef{}{oo-answers}{\section{Quiz answers}\label{oo-answers}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  To determine the OO system of an object, you use a process of
  elimination. If \texttt{!is.object(x)}, it's a base object. If
  \texttt{!isS4(x)}, it's S3. If \texttt{!is(x, "refClass")}, it's S4;
  otherwise it's RC.
\item
  Use \texttt{typeof()} to determine the base class of an object.
\item
  A generic function calls specific methods depending on the class of it
  inputs. In S3 and S4 object systems, methods belong to generic
  functions, not classes like in other programming languages.
\item
  S4 is more formal than S3, and supports multiple inheritance and
  multiple dispatch. RC objects have reference semantics, and methods
  belong to classes, not functions.
\end{enumerate}
